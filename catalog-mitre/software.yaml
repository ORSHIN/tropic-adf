---
# Firmware-related threats

#
# This dictionary represents the MITRE EM3ED System Software and Application Software Threat Cathegories
#


fw_verif_skip:
  a: Firmware verification skip
  d:
    Hardware fault tolerance: [Spatial/temporal redundancy, Register ECC, Hardened PC, Hardened CSRs]
    Bus protocol hardening: [Bus handshake signals, Bus integrity signals]
    Software implemented fault tolerance: [Redundant execution, Control flow integrity enforcement]
    Fault injection testing: [FI simulation, FI emulation, Software FI]
  surf: [Bootloader Execution]
  vect: [Fault Injection, Instruction Skip, Control Flow Modification]
  model: [Physical Access, Active]
  tag: ["SCA"]

data_extraction:
  a: Sensitive data extraction
  d:
    Noise introduction: [Dummy instruction insertion, Random instruction hints]
    Power balancing: [Power consumption estimation]
    Constant-time implementation: [Data independent timing]
    Reduction of profiling infrastructure: [Reduced performance counter in non-machine mode]
  surf: [Cryptographic Operation]
  vect: [Side-Channel Leakage, Power Analysis, Electromagnetic Analysis]
  model: [Physical Access, Active, Passive]
  tag: ["SCA"]

code_exe:
  a: Arbitrary code execution
  d:
    Proper memory management: [ASLR, Input validation, Bounds checking, Non-executable stack, Canaries]
    Code analysis: [Manual, Static, Dynamic]
    Secure Boot Verification: [Secure Boot, Code Signing, Secure Boot Keys]
    Firmware Integrity Checks: [Integrity Verification, Digital Signatures, Hash Functions]
  surf: [Bootloader, Memory Management]
  vect: [Buffer Manipulation, Pointer Manipulation, Firmware Verification Skip, NVM Tampering, Buffer Overflow]
  model: [Physical Access, Active]
  tag: ["Malicious Code"]

boot_cf_sca:
  a: Secure bootloader control flow analysis
  d:
    Noise introduction: [Dummy instruction insertion, Random instruction hints]
    Power balancing: [Power consumption estimation]
    Constant-time implementation: [Data independent timing]
  surf: [Bootloader Execution]
  vect: [Side-Channel Leakage, Power Analysis, Electromagnetic Analysis]
  model: [Physical Access, Passive]
  tag: ["Reverse Engineering"]

mal_firmw:
  a: Key material extraction from SE through malicious firmware
  d:
    Key storage: [Physical memory protection, Physical memory attribution, Machine mode access only]
    Secure Boot Verification: [Secure Boot, Code Signing, Secure Boot Keys]
    Firmware Integrity Checks: [Integrity Verification, Digital Signatures, Hash Functions]
  surf: [Non-Volatile Memory, Firmware RoT]
  vect: [Malicious Firmware, Vulnerable Firmware Image Verification, Memory Corruption, NVM Tampering]
  model: [Physical Access, Active]
  tag: ["Malicious Code"]

buff_overflow_fi:
  a: Buffer overflow exploitation after fault injection
  d:
    Proper memory management: [ASLR, Input validation, Bounds checking, Non-executable stack, Canaries]
    Code analysis: [Manual, Static, Dynamic]
    Hardware fault tolerance: [Spatial/temporal redundancy, Register ECC, Hardened PC, Hardened CSRs]
    Software implemented fault tolerance: [Redundant execution, Control flow integrity enforcement]
    Fault injection testing: [FI simulation, FI emulation, Software FI]
  surf: [Bootloader Execution, Debug Interface]
  vect: [Fault Injection, Instruction Skip, Control Flow Modification]
  model: [Physical Access, Active]
  tag: ["FI"]

timing_info:
  a: Collection of timing information
  d:
    Noise introduction: [Dummy instruction insertion, Random instruction hints]
    Power balancing: [Power consumption estimation]
    Reduction of profiling infrastructure: [Reduced performance counter in non-machine mode]
    Constant-time implementation: [Data independent timing]
  surf: [Bootloader]
  vect: [Profiling, Power Analysis, Electromagnetic Analysis, Code Execution, Hardware Performance Counter]
  model: [Physical Access, Passive]
  tag: ["SCA"]

evict_reload:
  # Primary fields
  a: If the attacker and the victim have shared memory, the attacker can observe the victim's behavior regarding this shared memory by observing the cache state. If the attacker evicts a shared value of interest from the cache, then loads the value again after the victim's execution, based on the time taken it can determine whether the victim accessed the same value.
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
    "avoiding shared memory": ["duplicate shared memory such as libraries"]
    "removing the contention": ["cache partitioning"]
    "making the leakage probabilistic": ["randomize the cache replacement policy"]
  surf: ["Cache Memory"]
  vect: ["Cache State"]
  model: ["Remote Code Execution"]
  tag: ["Cache Attack"]


flush_reload:
  # Primary fields
  a: If the attacker and the victim have shared memory, the attacker can observe the victim's behavior regarding this shared memory by observing the cache state. If the attacker flushes a shared value of interest from the cache, then loads the value again after the victim's execution, based on the time taken it can determine whether the victim accessed the same value.
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
    "avoiding shared memory": ["duplicate shared memory such as libraries"]
    "removing flush capability": ["making the flush instruction priviliged", "removing the flush instruction"]
    "removing the contention": ["cache partitioning"]
    "making the leakage probabilistic": ["randomize the cache replacement policy"]
  surf: ["Cache Memory"]
  vect: ["Cache State", "Flush Instruction"]
  model: ["Remote Code Execution"]
  tag: ["Cache Attack"]


flush_flush:
  # Primary fields
  a: If the attacker and the victim have shared memory, the attacker can observe the victim's behavior regarding this shared memory by observing the cache state. If the attacker flushes a shared value of interest from the cache, then flushes value again after the victim's execution, based on the time taken it can determine whether the victim accessed the same value (without ever accessing the target value).
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
    "avoiding shared memory": ["duplicate shared memory such as libraries"]
    "removing flush capability": ["making the flush instruction priviliged", "removing the flush instruction"]
    "removing the contention": ["cache partitioning"]
    "making the leakage probabilistic": ["randomize the cache replacement policy"]
  surf: ["Cache Memory"]
  vect: ["Cache State", "Flush Instruction"]
  model: ["Remote Code Execution"]
  tag: ["Cache Attack"]


prime_probe:
  # Primary fields
  a: Even without shared memory, the attacker can observe the victim's behavior regarding certain memory addresses by observing the cache state. If the attacker sets up the cache to a known state, then observes which values were evicted, it learns some information about the victim's execution, depending on the cache organization and replacement policy.
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
    "removing the contention": ["cache partitioning"]
    "making the leakage probabilistic": ["randomize the cache replacement policy"]
  surf: ["Cache Memory"]
  vect: ["Cache State"]
  model: ["Remote Code Execution"]
  tag: ["Cache Attack"]

nemesis:
  # Primary fields
  a: The number of executed instructions and their execution time can be measured by an attacker with interrupt capabilities.
  d:
    "constant-time code": ["make instruction counts and latencies independent of secrets"]
    "disabling interrupts": ["Disable the attacker's interrupt capabilities"]
    "masking the latency": ["The execution time of instructions can be masked by applying an interrupt padding scheme"]
  surf: ["Interrupt Capabilities"]
  vect: ["Adversary Code Execution"]
  model: ["Remote Code Execution"]
  tag: ["Shared Resource"]

port_contention:
  # Primary fields
  a: If the attacker can measure the execution time of code executing in parallel with the victim on the same core, they can detect changes in the timing resulting from the two programs contending for the same execution port on the core.
  d:
    "constant-time code": ["make execution port usage independent of secrets"]
    "disable hyperthreading": ["Allocate a dedicated core for the victim process"]
  surf: ["Hyperthreading"]
  vect: ["Adversary Code Execution"]
  model: ["Remote Code Execution"]
  tag: ["Shared Resource"]

bus_contention:
  # Primary fields
  a: If the victim and the attacker (either from code or through DMA) can access memory at the same time, this might lead to contention on the memory bus, making it possible to detect the victim's memory accesses.
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
  surf: ["BUS"]
  vect: ["Shared Memory"]
  model: ["Remote Code Execution"]
  tag: ["Shared Resource"]

page_table:
  # Primary fields
  a: By monitoring the state of page table mappings, a privileged attacker can reconstruct the access patterns of the victim.
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
    "remove privileges": ["make page table management a responsibility of the victim's domain"]
  surf: ["Priviledged Mode"]
  vect: ["Adversary Code Execution"]
  model: ["Privileged Execution"]
  tag: ["Privileged Execution"]

drama:
  # Primary fields
  a: Contention in the DRAM row buffer can leak the memory access patterns of a victim program.
  d:
    "constant-time code": ["make memory accesses independent of secrets"]
  surf: ["Memory"]
  vect: ["Shared Memory"]
  model: ["Remote Code Execution"]
  tag: ["Shared Resource"]
